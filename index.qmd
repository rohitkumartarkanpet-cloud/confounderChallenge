---
title: "Using Randomization & Stratification to Overcome a Common Cause Confounder"
subtitle: "Doc Dreamy vs Doc Duck"
format:
  html:
    toc: true
    toc-depth: 2
    number-sections: true
    fig-align: center
    fig-width: 7
    fig-height: 4
execute:
  echo: false
  eval: true
  warning: false
  message: false
---

```{=html}
<style>
.quarto-figure img, img {
  max-width: 100%;
  height: auto;
}
</style>
```

## Story Setup: Two Surgeons, Very Different Looks

<div style="float: right; margin-left: 15px; margin-bottom: 10px;">
<img src="docSideBySide.jpg" alt="Doc Dreamy and Doc Duck side by side" style="max-width: 220px; height: auto; border-radius: 5px;">
</div>

Imagine you need surgery and you can choose between two surgeons at the same hospital.

- **Doc Dreamy** looks exactly how people expect a surgeon to look. Calm, polished, nice office, diplomas on the wall.
- **Doc Duck** looks rough. Bigger build, messy office, and not much on the walls.

Most people would feel safer picking Doc Dreamy. But looks can hide what is really going on in the data. Here we walk through data for these two doctors and see how a hidden factor can flip the story.

## Data and Notation

```{python}
#| label: load-data
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Load observational and randomized data from CSV
patients_df = pd.read_csv("patients_data.csv")
patients_randomized_df = pd.read_csv("patients_data_randomized.csv")

# Color choices and background for dark-style figures
dreamy_color = "#7C3AED"  # violet
duck_color   = "#22C55E"  # green
bg_color     = "#020617"  # very dark background
grid_color   = "#4B5563"  # gray grid

n_patients_obs = len(patients_df)
n_patients_rnd = len(patients_randomized_df)
```

We work with two data sets:

- **Observational data**: patients picked their surgeon based on real-world factors like looks, waiting time, and personal preference.
- **Randomized data**: patients were assigned to surgeons by something like a coin flip.

The main outcome is:

- `post_surgical_score` – symptom score after surgery (lower values mean better recovery).

We also have:

- `severity` – how serious the case was before surgery.
- `doctor_name` – `"Doc Dreamy"` or `"Doc Duck"`.

## Observational Data: First Impression Favors Doc Dreamy

In the observational data, patients did not get assigned randomly. They chose a surgeon based on what they saw and how urgent they felt their case was.

### Summary of Observational Outcomes

```{python}
#| label: tbl-observational-summary

summary_obs = (
    patients_df
    .groupby("doctor_name")
    .agg(
        n=("post_surgical_score", "size"),
        mean_score=("post_surgical_score", "mean"),
        std_score=("post_surgical_score", "std"),
        mean_severity=("severity", "mean"),
    )
    .reset_index()
)

def style_summary(df):
    return (
        df.style
        .format({
            "mean_score": "{:.2f}",
            "std_score": "{:.2f}",
            "mean_severity": "{:.2f}",
        })
        .set_table_attributes('class="table table-striped table-bordered"')
        .set_properties(**{"text-align": "center"})
        .set_table_styles([
            {"selector": "th",
             "props": [("background-color", "#111827"),
                       ("color", "white"),
                       ("padding", "8px")]},
            {"selector": "td",
             "props": [("padding", "6px")]}
        ])
        .background_gradient(axis=0, cmap="plasma", subset=["mean_score"])
    )

style_summary(summary_obs)
```

In this setting, Doc Dreamy has the lower average post-surgical score, so at first glance it looks like he is doing better. But this conclusion is based on raw averages only.

### Figure 1 – Observational Outcomes by Patient

```{python}
#| label: fig-observational
#| fig-cap: "Observed post-surgical symptom scores for each patient by surgeon."
#| out-width: "100%"
#| fig-align: "center"

fig, ax = plt.subplots(figsize=(7, 4), facecolor=bg_color)
ax.set_facecolor(bg_color)

dreamy = patients_df[patients_df["doctor_name"] == "Doc Dreamy"]
duck   = patients_df[patients_df["doctor_name"] == "Doc Duck"]

# Slight jitter on x so overlapping markers are easier to see
rng = np.random.default_rng(123)
jitter_dreamy = rng.uniform(-0.15, 0.15, size=len(dreamy))
jitter_duck   = rng.uniform(-0.15, 0.15, size=len(duck))

# Scatter points with a bit of glow effect
for size, alpha in [(70, 0.9), (120, 0.15)]:
    ax.scatter(
        dreamy["patient"] + jitter_dreamy,
        dreamy["post_surgical_score"],
        s=size,
        marker="o",
        edgecolor="white",
        linewidth=0.5,
        color=dreamy_color,
        alpha=alpha,
        label="Doc Dreamy" if size == 70 else None,
        zorder=3,
    )
    ax.scatter(
        duck["patient"] + jitter_duck,
        duck["post_surgical_score"],
        s=size,
        marker="^",
        edgecolor="white",
        linewidth=0.5,
        color=duck_color,
        alpha=alpha,
        label="Doc Duck" if size == 70 else None,
        zorder=3,
    )

mean_dreamy = dreamy["post_surgical_score"].mean()
mean_duck   = duck["post_surgical_score"].mean()

ax.axhline(mean_dreamy, linestyle="--", color=dreamy_color, linewidth=2, alpha=0.9)
ax.axhline(mean_duck,   linestyle="--", color=duck_color,   linewidth=2, alpha=0.9)

# Place mean labels inside the plotting area
x_center = n_patients_obs * 0.7
ax.text(
    x_center,
    mean_dreamy,
    f"○ Doc Dreamy mean = {mean_dreamy:.2f}",
    color=dreamy_color,
    fontsize=10,
    va="bottom",
    ha="left",
)
ax.text(
    x_center,
    mean_duck,
    f"△ Doc Duck mean = {mean_duck:.2f}",
    color=duck_color,
    fontsize=10,
    va="top",
    ha="left",
)

ax.set_xlabel("Patient number", color="white", fontsize=11)
ax.set_ylabel("Post-surgical symptom score (lower is better)", color="white", fontsize=11)
ax.set_title("Post-surgical symptom scores – observational data", color="white", fontsize=13, pad=10)

ax.grid(True, linestyle=":", color=grid_color, alpha=0.6)
ax.set_xlim(0, n_patients_obs + 1)

# Style tick labels and legend
ax.tick_params(colors="white")
legend = ax.legend(frameon=False, loc="upper right")
for text in legend.get_texts():
    text.set_color("white")

plt.tight_layout()
plt.show()
```

Looking only at this figure and the earlier summary, the obvious answer is:

> Doc Dreamy looks better in the observational data because his patients have lower scores on average.

But this ignores how patients ended up with each surgeon.

## The Hidden Variable: Severity as a Common Cause

A directed graph (DAG) helps to keep the story straight.

![First mental model: surgeon directly affects outcome.](dag-example-node.png){#fig-example-node width=55%}

If we believe this drawing, we might think that the surgeon is the main reason for the outcome differences. But suppose severity affects both who the patient chooses and how they recover.

![Alternate model: severity influences both surgeon choice and outcome.](dag-example2-node.png){#fig-example2-node width=55%}

In this second drawing, severity is a common cause. Less severe cases may feel they can wait longer and go with the surgeon who looks more polished. More severe cases may just want the earliest available appointment, even if that means going to the surgeon who looks less polished.

If severity pushes easier cases toward Doc Dreamy and tougher cases toward Doc Duck, the raw averages will be biased in favor of Doc Dreamy, even if Doc Duck is actually better at surgery.

## Breaking the Link: Randomized Assignment

One way to break the connection between severity and surgeon choice is to assign surgeons at random.

![Randomization breaks the link between severity and surgeon choice.](dag-example3-node.png){#fig-example3-node width=65%}

In the randomized data, surgeon assignment no longer depends on severity. This lets us see the effect of surgeon identity more directly.

### Summary of Randomized Outcomes

```{python}
#| label: tbl-randomized-summary

summary_rnd = (
    patients_randomized_df
    .groupby("doctor_name")
    .agg(
        n=("post_surgical_score", "size"),
        mean_score=("post_surgical_score", "mean"),
        std_score=("post_surgical_score", "std"),
        mean_severity=("severity", "mean"),
    )
    .reset_index()
)

style_summary(summary_rnd)
```

Here the story changes. The randomized summary shows which surgeon tends to have the better outcomes once the severity imbalance has been removed.

### Figure 2 – Randomized Outcomes by Patient

```{python}
#| label: fig-randomized
#| fig-cap: "Post-surgical symptom scores under randomized surgeon assignment."
#| out-width: "100%"
#| fig-align: "center"

fig, ax = plt.subplots(figsize=(7, 4), facecolor=bg_color)
ax.set_facecolor(bg_color)

dreamy_r = patients_randomized_df[patients_randomized_df["doctor_name"] == "Doc Dreamy"]
duck_r   = patients_randomized_df[patients_randomized_df["doctor_name"] == "Doc Duck"]

rng = np.random.default_rng(456)
jitter_dreamy_r = rng.uniform(-0.15, 0.15, size=len(dreamy_r))
jitter_duck_r   = rng.uniform(-0.15, 0.15, size=len(duck_r))

for size, alpha in [(70, 0.9), (120, 0.15)]:
    ax.scatter(
        dreamy_r["patient"] + jitter_dreamy_r,
        dreamy_r["post_surgical_score"],
        s=size,
        marker="o",
        edgecolor="white",
        linewidth=0.5,
        color=dreamy_color,
        alpha=alpha,
        label="Doc Dreamy" if size == 70 else None,
        zorder=3,
    )
    ax.scatter(
        duck_r["patient"] + jitter_duck_r,
        duck_r["post_surgical_score"],
        s=size,
        marker="^",
        edgecolor="white",
        linewidth=0.5,
        color=duck_color,
        alpha=alpha,
        label="Doc Duck" if size == 70 else None,
        zorder=3,
    )

mean_dreamy_r = dreamy_r["post_surgical_score"].mean()
mean_duck_r   = duck_r["post_surgical_score"].mean()

ax.axhline(mean_dreamy_r, linestyle="--", color=dreamy_color, linewidth=2, alpha=0.9)
ax.axhline(mean_duck_r,   linestyle="--", color=duck_color,   linewidth=2, alpha=0.9)

x_center_r = n_patients_rnd * 0.7
ax.text(
    x_center_r,
    mean_dreamy_r,
    f"○ Doc Dreamy mean = {mean_dreamy_r:.2f}",
    color=dreamy_color,
    fontsize=10,
    va="bottom",
    ha="left",
)
ax.text(
    x_center_r,
    mean_duck_r,
    f"△ Doc Duck mean = {mean_duck_r:.2f}",
    color=duck_color,
    fontsize=10,
    va="top",
    ha="left",
)

ax.set_xlabel("Patient number", color="white", fontsize=11)
ax.set_ylabel("Post-surgical symptom score (lower is better)", color="white", fontsize=11)
ax.set_title("Post-surgical symptom scores – randomized assignment", color="white", fontsize=13, pad=10)

ax.grid(True, linestyle=":", color=grid_color, alpha=0.6)
ax.set_xlim(0, n_patients_rnd + 1)

ax.tick_params(colors="white")
legend = ax.legend(frameon=False, loc="upper right")
for text in legend.get_texts():
    text.set_color("white")

plt.tight_layout()
plt.show()
```

In this figure, the average lines tell a different story than before. Once surgeon assignment is separated from severity, the advantage seen in the observational data can disappear or reverse.

Randomization answers the question:

> If two groups of patients with similar severity are assigned to surgeons by chance, who does better on average?

## When Randomization Is Not Possible: Stratification by Severity

In many real settings we cannot randomize who gets which treatment. A common plan in that case is to compare outcomes **within bands of severity** so that we are comparing people who started in roughly the same state.

Here we look at initial severity on the x-axis and post-surgical score on the y-axis, using the observational data.

### Figure 3 – Outcomes by Severity (Stratified View)

```{python}
#| label: fig-severity
#| fig-cap: "Post-surgical symptom scores versus initial severity, highlighting the region where both surgeons see many patients."
#| out-width: "100%"
#| fig-align: "center"

fig, ax = plt.subplots(figsize=(7, 4), facecolor=bg_color)
ax.set_facecolor(bg_color)

dreamy = patients_df[patients_df["doctor_name"] == "Doc Dreamy"]
duck   = patients_df[patients_df["doctor_name"] == "Doc Duck"]

for size, alpha in [(70, 0.9), (120, 0.15)]:
    ax.scatter(
        dreamy["severity"],
        dreamy["post_surgical_score"],
        s=size,
        marker="o",
        edgecolor="white",
        linewidth=0.5,
        color=dreamy_color,
        alpha=alpha,
        label="Doc Dreamy" if size == 70 else None,
        zorder=3,
    )
    ax.scatter(
        duck["severity"],
        duck["post_surgical_score"],
        s=size,
        marker="^",
        edgecolor="white",
        linewidth=0.5,
        color=duck_color,
        alpha=alpha,
        label="Doc Duck" if size == 70 else None,
        zorder=3,
    )

# Highlight the region with overlapping severity values
ax.axvspan(-1, 1, color="#6B7280", alpha=0.18, zorder=1)

mean_dreamy_obs = dreamy["post_surgical_score"].mean()
mean_duck_obs   = duck["post_surgical_score"].mean()

ax.axhline(mean_dreamy_obs, linestyle="--", color=dreamy_color, linewidth=2, alpha=0.9)
ax.axhline(mean_duck_obs,   linestyle="--", color=duck_color, linewidth=2, alpha=0.9)

x_for_text = patients_df["severity"].max() - 0.5

ax.text(
    x_for_text,
    mean_dreamy_obs,
    f"○ Doc Dreamy mean = {mean_dreamy_obs:.2f}",
    color=dreamy_color,
    fontsize=10,
    va="bottom",
    ha="right",
)
ax.text(
    x_for_text,
    mean_duck_obs,
    f"△ Doc Duck mean = {mean_duck_obs:.2f}",
    color=duck_color,
    fontsize=10,
    va="top",
    ha="right",
)

ax.set_xlabel("Initial patient severity", color="white", fontsize=11)
ax.set_ylabel("Post-surgical symptom score (lower is better)", color="white", fontsize=11)
ax.set_title("Post-surgical symptom scores by initial severity – observational data", color="white", fontsize=13, pad=10)

ax.grid(True, linestyle=":", color=grid_color, alpha=0.6)
ax.tick_params(colors="white")

legend = ax.legend(frameon=False, loc="upper right")
for text in legend.get_texts():
    text.set_color("white")

plt.tight_layout()
plt.show()
```

Inside the shaded band between -1 and 1 on the x-axis, both surgeons have a good number of patients. This is the best place to compare them fairly using the observational data.

### Summary Inside the Overlap Band

```{python}
#| label: tbl-overlap-summary

overlap = patients_df[(patients_df["severity"] >= -1) & (patients_df["severity"] <= 1)]

summary_overlap = (
    overlap
    .groupby("doctor_name")
    .agg(
        n=("post_surgical_score", "size"),
        mean_score=("post_surgical_score", "mean"),
        std_score=("post_surgical_score", "std"),
        mean_severity=("severity", "mean"),
    )
    .reset_index()
)

style_summary(summary_overlap)
```

Now the comparison is made for patients who started with similar severity. This reduces the bias from the common cause and gives a fairer comparison.

Within this overlap band, Doc Duck often looks stronger than the raw overall averages suggest.

## Main Lessons

1. **Raw averages can mislead.** In the observational data, Doc Dreamy looks better at first only because he sees easier cases on average.
2. **Randomization breaks the path from severity to treatment.** In the randomized data, assignment no longer depends on severity, so the difference in averages reflects the effect of the surgeons more directly.
3. **Stratification is a backup when randomization is not available.** Comparing outcomes within bands of severity helps control the common cause and gives a fairer comparison.

The three figures and the summary tables together show:

- How a hidden variable (severity) can tilt the numbers.
- How randomization fixes the problem.
- How stratification can approximate that fix when randomization is not an option.
